"""
WebSocket Handler - Connection Orchestration

This module handles the WebSocket connection lifecycle:
1. Accept incoming connections
2. Receive messages from clients
3. Validate input
4. Orchestrate LLM → TTS flow
5. Send responses back
6. Handle errors gracefully

"""

import base64
from fastapi import WebSocket, WebSocketDisconnect
from pydantic import ValidationError

from src.models import ClientMessage, ServerMessage
from src.llm_service import get_llm_response
from src.tts_service import get_tts_audio


async def handle_websocket(websocket: WebSocket):
    """
    Handle a WebSocket connection.
    
    Flow:
    1. Accept connection
    2. Loop: receive → validate → LLM → TTS → respond
    3. Continue until client disconnects or error occurs
    
    Args:
        websocket: FastAPI WebSocket connection object

    Returns:
        It has no return - it sends data asynchronously over the WebSocket connection 
        
    """
    
    # Step 1: Accept the WebSocket connection
    await websocket.accept()
    # At this point, handshake is complete and we can send/receive
    
    try:
        # Step 2: Keep connection open for multiple messages
        while True:
            # ========================================
            # RECEIVE & VALIDATE
            # ========================================
            
            # Receive JSON from client
            # This will wait (non-blocking) until client sends something
            data = await websocket.receive_json()
            
            # Validate using our Pydantic model
            try:
                message = ClientMessage(**data)
                # If we reach here, message.text is guaranteed:
                # - String type
                # - 1-1000 characters
                # - Not empty/whitespace-only
                
            except ValidationError as e:
                # Client sent invalid data (missing field, wrong type, etc.)
                await send_error(
                    websocket,
                    f"Invalid message format: {str(e)}"
                )
                continue  # Don't process, wait for next message
            
            # ========================================
            # ORCHESTRATE: LLM → TTS
            # ========================================
            
            try:
                # Step 3: Call LLM service
                llm_text = await get_llm_response(message.text)
                
                # Step 4: Call TTS service
                audio_bytes = await get_tts_audio(llm_text)
                
                # Step 5: Encode audio as base64 for JSON transport
                # JSON can't hold raw bytes, so we encode
                audio_base64 = base64.b64encode(audio_bytes).decode('utf-8')
                
                # Step 6: Build response using ServerMessage model
                response = ServerMessage(
                    type="audio",
                    audio_data=audio_base64,
                    llm_text=llm_text
                    # timestamp is auto-generated by model
                )
                
                # Step 7: Send back to client
                await websocket.send_json(response.model_dump())
                # model_dump() converts Pydantic model to dict
                
            except Exception as e:
                # Something went wrong with LLM or TTS
                # Could be: timeout, rate limit, network error, API error
                await send_error(
                    websocket,
                    f"Service error: {str(e)}"
                )
                # Don't close connection - let client retry
                continue
    
    except WebSocketDisconnect:
        # Client disconnected gracefully
        # This is normal - don't log as error
        pass
    
    except Exception as e:
        # Unexpected error (shouldn't happen, but handle anyway)
        try:
            await send_error(websocket, f"Unexpected error: {str(e)}")
        except:
            # Can't even send error (connection probably dead)
            pass


async def send_error(websocket: WebSocket, error_message: str):
    """
    Send an error message to the client.
    
    Helper function to keep error responses consistent.
    Always uses ServerMessage format with type="error".
    
    Args:
        websocket: The WebSocket connection
        error_message: Human-readable error description
        
    """
    error_response = ServerMessage(
        type="error",
        error_message=error_message
        # timestamp auto-generated
    )
    await websocket.send_json(error_response.model_dump())
